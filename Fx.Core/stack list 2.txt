#pragma warning disable CS8500 // This takes the address of, gets the size of, or declares a pointer to a managed type
    public static class BetterSpan
    {
        public static unsafe BetterSpan<T> Create<T>(Span<T> values)
        {
            fixed (T* pointer = &values[0])
            {
                return new BetterSpan<T>(pointer, values.Length);
            }
        }

        public static unsafe BetterSpan<T> FromAllocated<T>(Span<byte> memory, int length) where T : allows ref struct
        {
            return new BetterSpan<T>(memory, length);
        }

        public static unsafe void Copy<T>(Span<byte> destination, ref T source) where T : allows ref struct
        {
            fixed (byte* pointer = destination)
            {
                System.Runtime.CompilerServices.Unsafe.Copy(pointer, ref source);
            }
        }
    }

    public unsafe ref struct BetterSpan<T> where T : allows ref struct
    {
        private readonly T* data;

        internal BetterSpan(T* data, int length)
        {
            this.data = data;
            this.Length = length;
        }

        internal BetterSpan(Span<byte> memory, int length)
        {
            if (memory.Length != System.Runtime.CompilerServices.Unsafe.SizeOf<T>() * length)
            {
                throw new Exception("TODO");
            }

            this.data = (T*)&memory;
            this.Length = length;
        }

        public T this[int index]
        {
            get
            {
                ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(index, this.Length);
                ArgumentOutOfRangeException.ThrowIfNegative(index);

                return this.data[index];
            }
            set
            {
                ArgumentOutOfRangeException.ThrowIfGreaterThanOrEqual(index, this.Length);
                ArgumentOutOfRangeException.ThrowIfNegative(index);

                this.data[index] = value;
            }
        }

        public int Length { get; }

        public static implicit operator T*(BetterSpan<T> betterSpan)
        {
            return betterSpan.data;
        }
    }

    public readonly ref struct LinkedListNode<T> where T : allows ref struct
    {
        private readonly BetterSpan<LinkedListNode<T>> previous;

        private readonly BetterSpan<T> values;

        public LinkedListNode(BetterSpan<T> values)
            : this(values, default)
        {
        }

        private LinkedListNode(BetterSpan<T> values, BetterSpan<LinkedListNode<T>> previous)
        {
            this.values = values;
            this.previous = previous;
        }

        public LinkedListNode<T> Append(BetterSpan<T> values, Span<byte> previousMemory)
        {
            if (previousMemory.Length != System.Runtime.CompilerServices.Unsafe.SizeOf<LinkedListNode<T>>())
            {
                throw new Exception("TODO");
            }

            var self = this;
            BetterSpan.Copy(previousMemory, ref self);

            return new LinkedListNode<T>(values, BetterSpan.FromAllocated<LinkedListNode<T>>(previousMemory, 1));
        }

        public ref struct Enumerator
        {
            private LinkedListNode<T> node;

            private int index;

            public Enumerator(LinkedListNode<T> node)
            {
                this.node = node;

                this.index = -1;
            }

            public T Current
            {
                get
                {
                    if (this.index < 0)
                    {
                        throw new Exception("TODO");
                    }

                    return node.values[this.index];
                }
            }

            public bool MoveNext()
            {
                if (this.index < 0)
                {
                    if (this.node.values.Length > 0)
                    {
                        this.index = 0;
                        return true;
                    }

                    if (node.previous.Length == 0)
                    {
                        return false;
                    }

                    this.node = node.previous[0];
                    return this.MoveNext();
                }

                if (this.index < this.node.values.Length - 1)
                {
                    ++this.index;
                    return true;
                }

                if (node.previous.Length == 0)
                {
                    return false;
                }

                this.node = node.previous[0];
                return this.MoveNext();
            }
        }
    }
#pragma warning restore CS8500 // This takes the address of, gets the size of, or declares a pointer to a managed type
